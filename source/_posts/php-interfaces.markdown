---
layout: post
title: "Интерфейсите на PHP"
date: 2012-10-01 09:02
comments: true
categories: PHP
---

PHP поддържа интерфейси още от версия 5.0. Това безспорно е солидна крачка напред към утвърждаването му като истински
обектно-ориентиран език за програмиране. Освен това обаче, PHP винаги е бил и ще бъде динамичен език - там е неговата
сила. Тези две характеристики често влизат в конфликт чието разрешаване налага компромиси. Случаят с интерфейсите е
точно такъв. Но дали е намерен оптималният балас?

<!-- MORE -->

Да се фокусираме за миг върху семантиката на думата **реализира**:

> Обекта `$a` от класа `A` **реализира** метода `foo()` точно тогава, когато израза `$a->foo()` води до изпълненето на
> определени (в спецификацията на метода `foo()`) действия и връщането на определен резултат.

Това е всичко - ни повече - ни по-малко. Друг начин да се изкаже същото е: Обектът `$a` реагира адекватно на
*съобщението* `foo`.

По нататък, по дефиниция, интерфейс е фиксиран набор от съобщения - т.е. набор от методи + техните параметри + техните
резултати. Един клас **реализира** (на англ. - implements) даден интерфейс точно тогава, когато реагира адекватно на
всички съобщения, дефинирани в интерфейса.

Да видим сега как стоят нещата в PHP с помощта на прост пример. Интефейса `I` има 
само един метод `foo()` и той е без параметри. Имаме и клас `A`:

```php
<?php

interface I
{
    public function foo();
}

...

class A
{
    public function __call($method, $args)
    {
        if ($method == 'foo') {
            return $this->bar();
        }
    }
    
    protected function bar() { ... }
}
```

Използваме "магическия метод"
[__call()](http://www.php.net/manual/bg/language.oop5.overloading.php#language.oop5.overloading.methods) който се
извиква всеки път, когато се извика несъществуващ или недостъпен метод на класа.

Да си отговорим сега на два въпроса:

  1. **Реализира ли класа `A` интерфейса `I`?**
  
     Очевидно - да! Фрагментът `$a = new A(); $a->foo()` е напълно леглен код на PHP. В случая той ще доведе до
     извикването на защитения метод `А::bar()`, но това са изцяло реализационни детайли. Погледнато отвън, `$a` има
     публичен метод`foo()` и той може да бъде извикван напълно легално.
    
  1. **Допустимо ли е да декларираме, че `class A implements I`?**

     Ето тук вече идва проблема. Ако го направим, резултатът е фатална грешка веднага щом кода на клас `A` бъде зареден.
    
Така достигнахме до парадокс - класа `A` де-факто поддържа интерфейс `I`, но очевидно не го прави начин, който се
харесва на PHP интерпретатора и поради това няма шанс да го заяви на околния свят. 

А това определено е проблем, който, макар и да звучи малко абстрактно си има съвсем конкретни практически измерения.
Например, в един от [проектите](https://github.com/bgerp/bgerp), по които работя напоследък, точно по тази причина с
нежелание взехме решение изобщо да не използваме PHP интерфейси.

Според мен причината за този проблем е конфликта, за който споменах в началото - между обектната ориентираност и
динамичната същност на PHP. Като динамичен език, PHP позволява динамично "инжектиране" на методи в класовете по време на
изпълнение. Ако се направи компромис с динамичността, целостта ще се възстанови. Но това в случая означава да се
премахне магическия метод
[__call()](http://www.php.net/manual/bg/language.oop5.overloading.php#language.oop5.overloading.methods) и въпреки
широко разпространеното мнение, че "магическите" методи на PHP са зло, аз изобщо не го споделям - все пак за тази цел си
има Java! 

Вероятно ако PHP интерпретатора не беше така (в случая - неадекватно) рестриктивен, или поне позволяваше да му се укаже
кога да не бъде, всичко щеше да е далеч по- чисто.

Бъдещето ще покаже ...
 



