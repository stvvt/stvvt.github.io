---
layout: post
title: PHP хапе
date: 2013-03-31 17:29:14
categories: PHP
---

Всички PHP програмисти знаят, че (от PHP 5) обектите се присвояват по reference, всичко останало - по стойност. Подобно
нещо е твърде важно и с твър де големи последствия, за да ти убегне или да го забравиш. Малко по-редки са случаите на
присвояване на масиви, чиито елементи са референции, но и там нещата са ясни и предсказуеми. Днес обаче PHP ме ухапа!
Натъкнах на ситуация, в която елементите на масив се държаха като референции, без всъщност да са такива. Това ми се
стори много странно и нелогично. Отне ми почти целия следобяд в търсене на причината и на начин за заобикалянето й.
Реших да споделя, с надеждата да спестя някому излишни боричкания.

<!-- MORE -->

Да вземем един прост пример:

```php
<?php

$v1 = 'first'; $v2 = 'second';

// Масив от референции
$arr = array(&$v1, &$v2);

// Копираме $arr в $copyArr
$copyArr = $arr;

// Копието съдържа същите референции и промяната на неговите елементи
// се отразява навсякъде
$copyArr[0] = 'third';

echo $v1;        // -> 'third';
echo $origArr[0] // -> 'third';
```

Магия тук няма. Въпреки, че присвояването на масиви е по стойност, елементите му си остават референции. За това
промяната на елемент на копието се отразява и върху съответния елемент на оригинала. Чудо голямо. Малко е неявно за
не-тренирано око, но като цяло всичко е наред.

## Е, и!? Какъв е проблемът?
Ето друг пример:

```php
<?php
// Обикновен PHP масив от стойности
$arr = array('first', 'second');

// Копираме $arr в $copyArr
$copyArr = $arr;

$copyArr[0] = 'third';

echo $arr[0];     // -> "first" (разбира се)
```

Фактите са факти - PHP присвоява масиви по стойност и толкова. Пак няма чудеса. Но да добавим само един ред към горния
пример. Един напълно безобиден ред …

```php
<?php
// Обикновен PHP масив от стойности
$arr = array('first', 'second');

// Това е новодобавеният ред - обикновена рефенеция към първия елемент
$ref = &$arr[0]; // <<< НОВО

// После продължава същото ... Копираме $arr в $copyArr
$copyArr = $arr;

$copyArr[0] = 'third';

echo $arr[0];     // -> "third" (разб... Опа-а! КАКВООО!?)
```

Ето това ми изяде целия следобяд (при това неделния, но … това е друга тема). По някаква причина, след присвояването по
референция, което добавихме в последния пример, поведението на масивите при копиране се променя, при това радикално.
Очевидно реда

```php
<?php
$ref = &$arr[0];
```
има страничен ефект върху самия $arr - става това, което нормално би станало ако $arr[0] е референция. Иначе казано,
след $ref = &$arr[0], $arr[0] магически се превръща в референция, въпреки, че преди това е най-обкиновена скаларна
стойност. Това, поне за мен, е странно и неочаквано. Свикнал съм да търся страничния ефект от присвояванията в лявата им
част, не и в дясната.

Изрично подчертавам, че става дума за PHP 5.4.6 под Ubuntu 12.10. За сега нямам информация дали същото е в сила за други
версии на PHP или в други ОС. Ако науча, ще пиша тук.

## И какво правим сега?
Възможно решение: изрично заместване на всеки елемент с неговата де-референсирана стойност:

```php
<?php
/**
* Премахва референциите от масив и ги заменя с техните стойности
*/
function dereference($arr)
{
   if (is_array($arr)) {
        foreach ($arr as $i=>$v) {
            unset($arr[$i]);
            $arr[$i] = dereference($v);
        }
    }

    return $arr;
}

$copyArr = dereference($arr);

$copyArr[0] = 'third';

echo $arr[0];     // -> "first" (както и трябва)
```
Надявам се това да е от полза на някого.